\"\"\"RGB per-pixel encoder for TimeFlowCodec (streaming, bounded memory).\"\"\"\n+from __future__ import annotations\n+\n+import struct\n+import tempfile\n+import warnings\n+from pathlib import Path\n+\n+import imageio.v2 as imageio\n+import numpy as np\n+\n+from .constants import (\n+    BITS_PER_MODE,\n+    COLOR_FORMAT_RGB,\n+    DEFAULT_SLOPE_THRESHOLD,\n+    DEFAULT_TAU,\n+    MODE_FB_RAW,\n+    MODE_TFC_CONST,\n+    MODE_TFC_LINEAR,\n+    PLANE_B,\n+    PLANE_G,\n+    PLANE_R,\n+)\n+from .format import build_plane_payload, pack_modes, write_header\n+from .utils import _ensure_rgb  # type: ignore\n+\n+\n+def _tile_indices(H: int, W: int, tile: int) -> tuple[np.ndarray, int, int]:\n+    tiles_y = (H + tile - 1) // tile\n+    tiles_x = (W + tile - 1) // tile\n+    tile_idx = np.arange(H * W, dtype=np.int64).reshape(H, W)\n+    tiles = np.zeros_like(tile_idx)\n+    for ty in range(tiles_y):\n+        for tx in range(tiles_x):\n+            y0 = ty * tile\n+            x0 = tx * tile\n+            y1 = min(H, y0 + tile)\n+            x1 = min(W, x0 + tile)\n+            tiles[y0:y1, x0:x1] = ty * tiles_x + tx\n+    return tiles.reshape(-1), tiles_y, tiles_x\n+\n+\n+def _encode_plane_from_stats(sum_s, sum_ts, sum_s2, T: int, tau: float, slope_threshold: float):\n+    \"\"\"\n+    Vectorized per-plane encode using precomputed sums to avoid storing frames.\n+    Returns per-pixel modes/params and fallback mask (bool array).\n+    \"\"\"\n+    n = float(T)\n+    N = sum_s.shape[0]\n+    modes = np.full((N,), MODE_FB_RAW, dtype=np.uint8)\n+    tfc_params: dict[int, dict] = {}\n+\n+    sum_t = n * (n - 1.0) / 2.0\n+    sum_t2 = (n - 1.0) * n * (2.0 * n - 1.0) / 6.0\n+    denom = n * sum_t2 - sum_t * sum_t\n+    b = np.where(denom == 0.0, 0.0, (n * sum_ts - sum_t * sum_s) / denom)\n+    a = (sum_s - b * sum_t) / n\n+\n+    rss = sum_s2 - 2 * a * sum_s - 2 * b * sum_ts + (a * a) * n + 2 * a * b * sum_t + (b * b) * sum_t2\n+    D_tfc = rss / n\n+    D_sig = sum_s2 / n + 1e-8\n+    r = D_tfc / D_sig\n+\n+    modeled = r <= tau\n+    const_mask = modeled & (np.abs(b) < slope_threshold)\n+    zero_mask = sum_s2 == 0\n+    const_mask |= zero_mask\n+    linear_mask = modeled & (~const_mask)\n+    fallback_mask = ~(const_mask | linear_mask)\n+\n+    modes[const_mask] = MODE_TFC_CONST\n+    modes[linear_mask] = MODE_TFC_LINEAR\n+\n+    for idx in np.nonzero(const_mask)[0]:\n+        tfc_params[int(idx)] = {\"mode\": MODE_TFC_CONST, \"a\": float(a[idx])}\n+    for idx in np.nonzero(linear_mask)[0]:\n+        tfc_params[int(idx)] = {\"mode\": MODE_TFC_LINEAR, \"a\": float(a[idx]), \"b\": float(b[idx])}\n+\n+    return modes, tfc_params, fallback_mask, int(const_mask.sum()), int(linear_mask.sum()), int(fallback_mask.sum())\n+\n+\n+def encode_video_to_tfc(\n+    input_path: str,\n+    output_path: str,\n+    tau: float = DEFAULT_TAU,\n+    slope_threshold: float = DEFAULT_SLOPE_THRESHOLD,\n+    payload_comp_type: int = 1,\n+    max_frames: int | None = None,\n+    window: int | None = None,\n+    tiling: int | None = None,\n+    max_ram_mb: int | None = None,\n+    dtype: str = \"uint8\",\n+) -> None:\n+    \"\"\"\n+    Streaming RGB encoder with bounded memory.\n+\n+    - Reads frames sequentially (ffmpeg via imageio).\n+    - Computes per-pixel (or per-tile) stats in one pass.\n+    - Second pass only for fallback pixels (optionally using memmap to cap RAM).\n+    \"\"\"\n+\n+    dtype_map = {\"uint8\": np.uint8, \"uint16\": np.uint16, \"float16\": np.float16}\n+    if dtype not in dtype_map:\n+        raise ValueError(\"Unsupported dtype; choose from uint8,uint16,float16\")\n+    np_dtype = dtype_map[dtype]\n+    tile_size = tiling if tiling and tiling > 1 else 1\n+\n+    reader = imageio.get_reader(input_path)\n+    frames_iter = iter(reader)\n+    try:\n+        first = next(frames_iter)\n+    except StopIteration as exc:  # noqa: B904\n+        raise ValueError(\"No frames found in input video\") from exc\n+    first_rgb = _ensure_rgb(first).astype(np_dtype, copy=False)\n+    H, W, _ = first_rgb.shape\n+    tile_idx_map, tiles_y, tiles_x = _tile_indices(H, W, tile_size)\n+    num_tiles = tiles_y * tiles_x\n+\n+    # Stats per tile per plane\n+    sum_s = [np.zeros((num_tiles,), dtype=np.float64) for _ in range(3)]\n+    sum_ts = [np.zeros((num_tiles,), dtype=np.float64) for _ in range(3)]\n+    sum_s2 = [np.zeros((num_tiles,), dtype=np.float64) for _ in range(3)]\n+\n+    frames_consumed = 0\n+    t_idx = 0\n+\n+    def accumulate(frame_arr: np.ndarray, t_val: int) -> None:\n+        flat = frame_arr.reshape(-1, 3)\n+        for c in range(3):\n+            ch = flat[:, c]\n+            ch_f = ch.astype(np.float64, copy=False)\n+            np.add.at(sum_s[c], tile_idx_map, ch_f)\n+            np.add.at(sum_ts[c], tile_idx_map, ch_f * t_val)\n+            np.add.at(sum_s2[c], tile_idx_map, ch_f * ch_f)\n+\n+    accumulate(first_rgb, t_idx)\n+    frames_consumed += 1\n+\n+    for frame in frames_iter:\n+        if max_frames is not None and frames_consumed >= max_frames:\n+            break\n+        t_idx += 1\n+        accumulate(_ensure_rgb(frame).astype(np_dtype, copy=False), t_idx)\n+        frames_consumed += 1\n+\n+    T = frames_consumed\n+\n+    plane_results = {}\n+    fallback_tiles = {}\n+    for plane, name in zip((PLANE_R, PLANE_G, PLANE_B), \"RGB\"):\n+        modes_tile, params_tile, fb_mask_tile, c_const, c_lin, c_raw_tiles = _encode_plane_from_stats(\n+            sum_s[plane], sum_ts[plane], sum_s2[plane], T, tau, slope_threshold\n+        )\n+        # expand per-pixel\n+        modes = modes_tile[tile_idx_map].astype(np.uint8, copy=False)\n+        tfc_params = {}\n+        for pix, tile_id in enumerate(tile_idx_map):\n+            if modes_tile[tile_id] == MODE_TFC_CONST:\n+                tfc_params[pix] = {\"mode\": MODE_TFC_CONST, \"a\": params_tile[int(tile_id)][\"a\"]}\n+            elif modes_tile[tile_id] == MODE_TFC_LINEAR:\n+                p = params_tile[int(tile_id)]\n+                tfc_params[pix] = {\"mode\": MODE_TFC_LINEAR, \"a\": p[\"a\"], \"b\": p[\"b\"]}\n+        fb_mask_pix = fb_mask_tile[tile_idx_map]\n+        plane_results[plane] = {\n+            \"modes\": modes,\n+            \"tfc_params\": tfc_params,\n+            \"fb_params\": {},\n+            \"counts\": (c_const * (tile_size * tile_size), c_lin * (tile_size * tile_size), int(fb_mask_pix.sum())),\n+        }\n+        fallback_tiles[plane] = fb_mask_pix\n+        print(f\"Plane {name}: Const~{c_const*tile_size*tile_size}, Linear~{c_lin*tile_size*tile_size}, Raw~{int(fb_mask_pix.sum())}\")\n+\n+    # Collect fallback samples only for required pixels (second pass)\n+    needs_fb = any(fallback_tiles[p].any() for p in (PLANE_R, PLANE_G, PLANE_B))\n+    if needs_fb:\n+        fb_indices = {p: np.nonzero(fallback_tiles[p])[0] for p in (PLANE_R, PLANE_G, PLANE_B)}\n+        fb_counts = {p: len(fb_indices[p]) for p in (PLANE_R, PLANE_G, PLANE_B)}\n+        total_fb = sum(fb_counts.values())\n+        est_mem = total_fb * T\n+        if max_ram_mb is not None and est_mem / (1024 * 1024) > max_ram_mb:\n+            warnings.warn(\n+                f\"Estimated fallback buffer {est_mem/1e6:.2f} MB exceeds max_ram_mb={max_ram_mb}. Using memmap (disk).\"\n+            )\n+        use_memmap = max_ram_mb is not None and est_mem / (1024 * 1024) > max_ram_mb\n+\n+        fb_buffers = {}\n+        tmpfiles = {}\n+        for plane in (PLANE_R, PLANE_G, PLANE_B):\n+            idxs = fb_indices[plane]\n+            if len(idxs) == 0:\n+                continue\n+            if use_memmap:\n+                tmpfile = tempfile.NamedTemporaryFile(delete=False)\n+                tmpfiles[plane] = tmpfile.name\n+                fb_buffers[plane] = np.memmap(tmpfile.name, dtype=np.uint8, mode=\"w+\", shape=(len(idxs), T))\n+            else:\n+                fb_buffers[plane] = np.empty((len(idxs), T), dtype=np.uint8)\n+\n+        reader2 = imageio.get_reader(input_path)\n+        for frame_idx, frame in enumerate(reader2):\n+            if frame_idx >= T:\n+                break\n+            flat = _ensure_rgb(frame).reshape(-1, 3).astype(np.uint8, copy=False)\n+            for plane in (PLANE_R, PLANE_G, PLANE_B):\n+                idxs = fb_indices[plane]\n+                if len(idxs) == 0:\n+                    continue\n+                fb_buffers[plane][:, frame_idx] = flat[idxs, plane]\n+\n+        for plane in (PLANE_R, PLANE_G, PLANE_B):\n+            idxs = fb_indices[plane]\n+            fb_params = {}\n+            buf = fb_buffers.get(plane)\n+            if buf is None:\n+                continue\n+            for buf_idx, pix_idx in enumerate(idxs):\n+                fb_params[int(pix_idx)] = np.array(buf[buf_idx]).astype(np.uint8, copy=False)\n+            plane_results[plane][\"fb_params\"] = fb_params\n+            if plane in tmpfiles:\n+                Path(tmpfiles[plane]).unlink(missing_ok=True)\n+\n+    header = {\n+        \"version\": 1,\n+        \"width\": W,\n+        \"height\": H,\n+        \"num_frames\": T,\n+        \"color_format\": COLOR_FORMAT_RGB,\n+        \"bits_per_mode\": BITS_PER_MODE,\n+        \"payload_comp_type\": payload_comp_type,\n+    }\n+\n+    with open(output_path, \"wb\") as f:\n+        write_header(f, header)\n+        for plane in (PLANE_R, PLANE_G, PLANE_B):\n+            modes = plane_results[plane][\"modes\"]\n+            f.write(pack_modes(modes, bits_per_mode=BITS_PER_MODE))\n+            payload = build_plane_payload(\n+                plane_results[plane][\"tfc_params\"],\n+                plane_results[plane][\"fb_params\"],\n+                T,\n+                payload_comp_type,\n+            )\n+            f.write(struct.pack(\"<I\", len(payload)))\n+            f.write(payload)\n+\n+    print(f\"Encoded {input_path} -> {output_path}. Frames={T}, Size={H}x{W}, Tiles={tiles_y}x{tiles_x}\")\n*** End Patch
